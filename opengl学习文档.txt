1 opengl 有意把渲染上下文和显示窗口从opengl规范中剥离出来

2 glad作用： 加载opengl的函数，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。目前glfw中提供了opengl3.3的glad，位于deps/glad/gl.h（仅头文件版本）。也就是说目前可以不需要自己去生成glad的代码。

3 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线
	图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。
	图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。
	图形渲染管线包括：
		顶点着色器：主要作用是把3D坐标转为另一种3D坐标，同时允许对顶点属性进行处理
		几何着色器
		形状（图元）装配
		光栅化：主要作用是把图元映射成最终屏幕上相应的像素，生成供片段着色器使用的片段
		片段着色器: 
			主要目的是计算一个像素的最终颜色。
			它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。
			如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。
		测试与混合
		
		NOTE: OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。
		
4 在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）

5 opengl标准化设备坐标: OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。 

6 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。

7 屏幕坐标,OpenGL标准设备坐标,纹理坐标
	屏幕坐标系： 
		基于窗口系统的坐标系。对于大多数窗口系统（如Windows、X11等），屏幕坐标通常是这样的：
			原点：位于屏幕左上角。
			方向：X轴向右增加；Y轴向下增加。
			单位：像素。
			
	OpenGL标准设备坐标：
		原点：位于屏幕中心。
		方向：X轴向右增加；Y轴向上增加；Z轴指向屏幕外。
		单位：归一化的值，范围通常为[-1, 1]。
		
		NOTE:一旦顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了

	从NDC坐标到屏幕坐标的转换
		float xScreen = ((xNDC + 1.0f) / 2.0f) * width;
		float yScreen = ((1.0f - yNDC) / 2.0f) * height;
	从屏幕坐标到NDC坐标的转换
		float xNDC = (2.0f * xScreen / width) - 1.0f;
		float yNDC = 1.0f - (2.0f * yScreen / height);

	纹理坐标：
		原点：位于屏幕左下角。
		方向：X轴向右增加；Y轴向上增加。
		单位：纹理坐标的范围是 [0, 1]

		NOTE:纹理空间，Direct3D (0，0)为左上角，OpenGL (0，0)为左下角

8 VAO作用：
	主要是当需要来回切换绘制不同物体时候，方便绘制。如果没有VAO，那么在来回绘制物体A和B时，需要每次重复把创建VBO那套代码都执行一次。

9 EBO(IBO)作用
	EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。
	比如通过两个三角形绘制一个矩形时候，两个三角形共有6个顶点，但矩形只需要四个顶点。这里就有重复的顶点。浪费资源。

10 什么是着色器：
	着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；
	它们之间唯一的沟通只有通过输入和输出。

11 顶点属性的位置值：
	layout (location = 0)	//强制指定
	glGetAttribLocation		//动态随机
	这两种方式都可以

12 如何从顶点着色器向片段着色器发送数据
	顶点着色器中定义输出变量，片段着色器中定义输入变量，并且这两个变量名字一样。这样就连接起来了。

	#version 330 core
	layout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0

	out vec4 vertexColor; // 为片段着色器指定一个颜色输出

	void main()
	{
		gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数
		vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色
	}
	///////////////////////
	#version 330 core
	out vec4 FragColor;

	in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）

	void main()
	{
		FragColor = vertexColor;
	}

13 应用程序在 CPU 上传递数据到 GPU 上的着色器的方式
	顶点数据
	uniform

14 unifrom注意事项：
	glGetUniformLocation 查询uniform地址不要求你之前使用过着色器程序
	glUniform4f 但是更新一个uniform之前你必须先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。
		f	函数需要一个float作为它的值
		i	函数需要一个int作为它的值
		ui	函数需要一个unsigned int作为它的值
		3f	函数需要3个float作为它的值
		fv	函数需要一个float向量/数组作为它的值

15 glVertexAttribPointer函数：
	第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。
	第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。
	第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。
	下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。
	第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。
	最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。

16 左手坐标系和右手坐标系对于编码区别：
	对于2D纹理而言，由于Direct3D (D3D) 和 OpenGL 在X轴和Y轴上的方向是相同的，
	因此对于2D纹理坐标而言，它们在两种坐标系统中的处理基本相同。

17 