1 opengl 有意把渲染上下文和显示窗口从opengl规范中剥离出来

2 glad作用： 加载opengl的函数，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。目前glfw中提供了opengl3.3的glad，位于deps/glad/gl.h（仅头文件版本）。也就是说目前可以不需要自己去生成glad的代码。

3 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线
	图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。
	图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。
	图形渲染管线包括：
		顶点着色器：
			主要作用是把3D坐标转为另一种3D坐标（gl_Position 裁剪坐标，opengl会自动进行透视除法），同时允许对顶点属性进行处理

			Q: 之前我们给顶点着色器设置坐标的时候gl_Position = uTransform * vec4(aPos, 1.0);如果把1.0改大看看效果？
			A: 可以看到物体变小了，这个就是透视除法作用了。

		几何着色器
		形状（图元）装配
		光栅化：主要作用是把图元映射成最终屏幕上相应的像素，生成供片段着色器使用的片段
		片段着色器: 
			主要目的是计算一个像素的最终颜色。
			它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。
			如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。
		测试与混合
		
		NOTE: OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。
		
4 在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）

5 opengl标准化设备坐标: OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。 

6 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。

7 屏幕坐标,OpenGL标准设备坐标,纹理坐标
	屏幕坐标系： 
		基于窗口系统的坐标系。对于大多数窗口系统（如Windows、X11等），屏幕坐标通常是这样的：
			原点：位于屏幕左上角。
			方向：X轴向右增加；Y轴向下增加。
			单位：像素。
			
	NOTE: 
	屏幕坐标通常根据原点位置分为以下两种：
		原点位于左上角：D3D，各种系统的窗口系统都使用这
		原点位于左下角：opengl （参考glViewport的前两个参数）

		NDC坐标->屏幕坐标：（x,y 是opengl原点左下角坐标）
			Xscreen = (Xndc + 1)*(width / 2) + x
			// （原点是左下角）
			Yscreen = (Yndc + 1)*(height / 2) + y
			// （原点是左上角，Y轴方向相反）
			Yscreen = (1 - Yndc)*(height / 2) - y

		Q: 如果根据NDC坐标，怎么获得操作系统的窗口里的坐标？
		A: 由于一般窗口坐标的原点是左上角，所以计算Y坐标的时候要用Yscreen = (1 - Yndc)*(height / 2) - y

	OpenGL标准设备坐标：
		原点：位于屏幕中心。
		方向：X轴向右增加；Y轴向上增加；Z轴指向屏幕外。
		单位：归一化的值，范围通常为[-1, 1]。
		
		NOTE:一旦顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了

	纹理坐标：
		原点：位于屏幕左下角。
		方向：X轴向右增加；Y轴向上增加。
		单位：纹理坐标的范围是 [0, 1]

		NOTE:纹理空间，Direct3D (0，0)为左上角，OpenGL (0，0)为左下角

8 VAO作用：
	主要是当需要来回切换绘制不同物体时候，方便绘制。如果没有VAO，那么在来回绘制物体A和B时，需要每次重复把创建VBO那套代码都执行一次。

9 EBO(IBO)作用
	EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。
	比如通过两个三角形绘制一个矩形时候，两个三角形共有6个顶点，但矩形只需要四个顶点。这里就有重复的顶点。浪费资源。

10 什么是着色器：
	着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；
	它们之间唯一的沟通只有通过输入和输出。

11 顶点属性的位置值：
	layout (location = 0)	//强制指定
	glGetAttribLocation		//动态随机
	这两种方式都可以

12 如何从顶点着色器向片段着色器发送数据
	顶点着色器中定义输出变量，片段着色器中定义输入变量，并且这两个变量名字一样。这样就连接起来了。

	#version 330 core
	layout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0

	out vec4 vertexColor; // 为片段着色器指定一个颜色输出

	void main()
	{
		gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数
		vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色
	}
	///////////////////////
	#version 330 core
	out vec4 FragColor;

	in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）

	void main()
	{
		FragColor = vertexColor;
	}

13 应用程序在 CPU 上传递数据到 GPU 上的着色器的方式
	顶点数据
	uniform

14 unifrom注意事项：
	glGetUniformLocation 查询uniform地址不要求你之前使用过着色器程序
	glUniform4f 但是更新一个uniform之前你必须先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。
		f	函数需要一个float作为它的值
		i	函数需要一个int作为它的值
		ui	函数需要一个unsigned int作为它的值
		3f	函数需要3个float作为它的值
		fv	函数需要一个float向量/数组作为它的值

15 glVertexAttribPointer函数：
	第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。
	第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。
	第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。
	第四个参数指定是否希望数据被标准化(Normalize)。只对固定的类型数据起作用，对float不起作用。
	第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。
	最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。

16 左手坐标系和右手坐标系对于编码区别：
	对于2D纹理而言，由于Direct3D (左手坐标系) 和 OpenGL(右手坐标系) 在X轴和Y轴上的方向是相同的，
	因此对于2D纹理坐标而言，它们在两种坐标系统中的处理基本相同。

17 经过顶点着色器处理后的顶点位置坐标通常会转换到归一化设备坐标（Normalized Device Coordinates, NDC）空间。
	NDC空间是一种标准化的坐标系统，在OpenGL中，NDC空间的坐标范围通常是-1到1。
	NDC:
		位置范围：-1，1
		颜色范围：0，1

18 赋值给gl_Position范围在-1，1之间的坐标就是裁剪空间坐标
	OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。
	OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到屏幕坐标，
	每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。
	这个过程称为视口变换。

19 什么是纹理的采样：
	使用纹理坐标获取纹理颜色叫做采样(Sampling)

20 关于纹理的一些概念：
	纹理数据: 
		实际的纹理数据（像素颜色值）是存储在一个纹理对象中的，该对象由 OpenGL 创建，并通过调用 glTexImage2D 或类似函数填充。
	纹理单元: 
		在OpenGL中，纹理单元是一组绑定的纹理，每个单元都有一个编号（例如 GL_TEXTURE0、GL_TEXTURE1 等）。
		您可以绑定多个纹理到不同的纹理单元，然后在着色器中使用这些纹理。
	纹理采样器: 
		sampler2D 是一个在着色器中使用的类型，它表示一个 2D 纹理采样器。
		它不直接存储纹理数据，而是告诉着色器应该从哪个纹理单元采样数据。

21 向量
	定义：向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)
	向量相加：就是每个向量的分量分别相加
	向量相减：就是一个向量加上另一个向量的反向量。
	向量相乘：
		点乘：
			两个向量的点乘等于向量的长度数乘结果乘以两个向量之间夹角的余弦值。：
			v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ
			如何计算点乘呢？点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。

			它们之间的夹角记作θ。为什么这很有用？想象如果v¯和k¯都是单位向量，它们的长度会等于1。
			这样公式会有效简化成：v¯⋅k¯=1⋅1⋅cosθ=cosθ
			现在点积只定义了两个向量的夹角。你也许记得90度的余弦值是0，0度的余弦值是1。
			使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）
		叉乘：
			叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。
			如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量

			叉乘的计算：
				Ax|		|Bx|		|Ay*Bz - Az*By
				Ay|	x	|By|	=	|Az*Bx - Ax*Bz
				Az|		|Bz|		|Ax*By - Ay*Bx

22 单位向量
	任意向量的每个分量除以向量的长度得到它的单位向量n^

23 矩阵
	矩阵索引：矩阵可以通过(i, j)进行索引，i是行，j是列

	矩阵加减法：
		矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。
		这也就是说加法和减法只对同维度的矩阵才是有定义的。
		一个3×2矩阵和一个2×3矩阵（或一个3×3矩阵与4×4矩阵）是不能进行加减的
	矩阵乘法：
		矩阵与标量相乘：
			和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的每一个元素分别乘以该标量
		矩阵与矩阵相乘：
			限制：
				只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。
				矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅A。

			结果矩阵的维度是(n, m)，n等于左侧矩阵的行数，m等于右侧矩阵的列数。

			矩阵与向量相乘（特殊的矩阵与矩阵相乘，向量可以看成是一个一列多行的矩阵）：
				
	单位矩阵：
		在OpenGL中，由于某些原因我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。
		我们能想到的最简单的变换矩阵就是单位矩阵(Identity Matrix)。单位矩阵是一个除了对角线以外都是0的N×N矩阵
		1 0 0 0
		0 1 0 0
		0 0 1 0
		0 0 0 1
		
		一个向量和单位矩阵相乘，结果还是这个向量，保持不变。

	缩放矩阵：
		（3D缩放矩阵,需要4x4矩阵）
		s1	0	0	0 |		|x|		|s1	* x
		0	s2	0	0 |	*	|y| =	|s2	* y
		0	0	s3	0 |		|z|		|s3	* z
		0	0	0	1 |		|1|		|	1

		（2D缩放矩阵，需要3x3矩阵）
		s1	0	0 |		|x|		|s1	* x
		0	s2	0 |	*	|y|	=	|s2	* y
		0	0	1 |		|1|		|	1

	位移：
		（3D位移矩阵,需要4x4矩阵）
		1	0	0	Tx |	|x|		|x + Tx
		0	1	0	Ty | *	|y|	=	|y + Ty
		0	0	1	Tz |	|z|		|z + Tz
		0	0	0	1  |	|1|		|  1
		
		2D位移矩阵需要3x3矩阵

		齐次坐标(Homogeneous Coordinates)
		向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。
		我们通常不会注意这个问题，因为w分量通常是1.0。
		使用齐次坐标有几点好处：
			它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。
		如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。
	旋转：
		旋转用角表示。角可以是角度制或弧度制

		Q: 什么是弧度？
		A: 它定义为当一个角的两条边分别沿着单位圆（半径为1的圆）的周长移动时，该角的大小等于其边所扫过的圆弧长度。

		NOTE: 
		圆的周长是：2*PI*R，当半径R=1,那么单位圆的周长就是2*PI.

		弧度转角度：角度 = 弧度 * (180.0f / PI)
		角度转弧度：弧度 = 角度 * (PI / 180.0f)

	矩阵组合：
		根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中
		在 OpenGL 中，矩阵变换是从右向左进行的，这意味着最后一个应用的变换最先作用于顶点上。
		   位移矩阵            缩放矩阵
		1	0	0	1 |		|2	0	0	0|		|2	0	0	1
		0	1	0	2 | *	|0	2	0	0|	=	|0	2	0	2
		0	0	1	3 |		|0	0	2	0|		|0	0	2	3
		0	0	0	1 |		|0	0	0	1|		|0	0	0	1

		2	0	0	1		x		2x + 1
		0	2	0	2	*	y	=	2y + 2	
		0	0	2	3		z		2z + 3
		0	0	0	1		1		   1

24 坐标系统
	局部空间
		model矩阵（包含平移，旋转，缩放）
	世界空间
		view矩阵（包含平移，旋转）：观察矩阵通常用来表示观察者的位置和方向
	观察空间
		projection矩阵（将三维空间中的顶点转换到裁剪坐标空间的过程）
			正射投影：不会修改向量的齐次坐标
			透视投影：会修改向量的齐次坐标。从而使得离观察者越远的顶点坐标w分量越大
	裁剪空间
		透视除法（将4D裁剪空间坐标变换为3D标准化设备坐标的过程），视口变换
	屏幕空间

	NOTE:
	裁剪坐标范围是【-w，w】,经过透视除法后的坐标是NDC坐标范围【-1，1】

	NOTE：
	注意在标准化设备坐标系中OpenGL实际上使用的是左手坐标系（投影矩阵交换了左右手）。

	Z缓冲（也被称为深度缓冲(Depth Buffer)）：
		OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。
		通过使用Z缓冲，我们可以配置OpenGL来进行深度测试。
	
		OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。
		GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。
		深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，
		如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。
		这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。

		深度测试（Depth Test）是 OpenGL 中用于确定哪些片段（像素）应该被绘制到屏幕上的一项重要功能。
		它可以帮助解决遮挡问题，即只绘制离摄像机最近的表面部分，隐藏那些被其他表面遮挡的部分。

25 Camera
	摄像机空间/观察空间的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标
	NOTE:
		这个很重要，因为在观察空间中，摄像机就是位于原点位置。

	观察矩阵：
		观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标
		包含两个部分：旋转和位移。

	要定义一个摄像机，我们需要四个东西：
		1 摄像机位置
		2 摄像机方向
		3 一个指向它右侧的向量
		4 一个指向它上方的向量

	实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。

	摄像机位置：
		世界空间中一个指向摄像机位置的向量
	摄像机方向：
		目标向量减去摄像机位置向量的结果向量的方向就是世界坐标系中摄像机朝向目标的方向。===》摄像机的前向方向
		用摄像机位置向量减去目标向量的结果向量再进行归一化后的单位向量就是方向向量。===》摄像机Z轴的正方向

		摄像机朝向世界坐标系中的负Z轴方向。
		（两个向量相减，就是一个向量加上负的一个向量。a-b = a+(-b);）
	摄像机右轴：

	摄像机上轴：
		
	观察矩阵：
					|Rx	Ry	Rz	0|		|1	0	0	-Px|
		LookAt	=	|Ux	Uy	Uz	0|	*	|0	1	0	-Py|	(方向向量构建的旋转矩阵)
					|Dx	Dy	Dz	0|		|0	0	1	-Pz|
					|0	0	0	1|		|0	0	0	1|

					|Rx		Ry	Rz	0|		|1	0	0	-Px|
		LookAt	=	|Ux		Uy	Uz	0|	*	|0	1	0	-Py|	(前向向量构建的旋转矩阵)
					|-Fx	-Fy	-Fz	0|		|0	0	1	-Pz|
					|0		0	0	1|		|0	0	0	1|
		NOTE:
			1 这里自定义的矩阵中的R，U,D，F都是摄像机的，不是世界的。glm::lookat的第三个参数up是世界的。
			2 方向向量和前向向量相反。
			3 先位移再旋转

		Q: 为什么我们希望方向向量指向摄像机的z轴正方向?
		A: 保持和世界坐标系一致（右手坐标系）

	欧拉角：
		俯仰角（pitch）：围绕X轴旋转，摄像机处于YZ平面
		偏航角（yaw）：围绕Y轴旋转，摄像机处于XZ平面
		滚转角（roll）: 围绕Z轴旋转，摄像机处于XY平面

		给定一个俯仰角和偏航角，我们可以把它们转换为一个代表方向向量的3D向量
		参考俯仰角和偏航角的图解，然后看如何根据这两个角度计算出一个3D向量

