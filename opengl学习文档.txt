1 opengl 有意把渲染上下文和显示窗口从opengl规范中剥离出来

2 glad作用： 加载opengl的函数，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。目前glfw中提供了opengl3.3的glad，位于deps/glad/gl.h（仅头文件版本）。也就是说目前可以不需要自己去生成glad的代码。

3 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线
	图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。
	图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。
	图形渲染管线包括：
		顶点着色器：主要作用是把3D坐标转为另一种3D坐标，同时允许对顶点属性进行处理
		几何着色器
		形状（图元）装配
		光栅化：主要作用是把图元映射成最终屏幕上相应的像素，生成供片段着色器使用的片段
		片段着色器: 
			主要目的是计算一个像素的最终颜色。
			它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。
			如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。
		测试与混合
		
		NOTE: OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。
		
4 在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）

5 opengl标准化设备坐标: OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。 

6 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。

7 屏幕坐标,OpenGL标准设备坐标,纹理坐标
	屏幕坐标系： 
		基于窗口系统的坐标系。对于大多数窗口系统（如Windows、X11等），屏幕坐标通常是这样的：
			原点：位于屏幕左上角。
			方向：X轴向右增加；Y轴向下增加。
			单位：像素。
			
	OpenGL标准设备坐标：
		原点：位于屏幕中心。
		方向：X轴向右增加；Y轴向上增加；Z轴指向屏幕外。
		单位：归一化的值，范围通常为[-1, 1]。
		
		NOTE:一旦顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了

	从NDC坐标到屏幕坐标的转换
		float xScreen = ((xNDC + 1.0f) / 2.0f) * width;
		float yScreen = ((1.0f - yNDC) / 2.0f) * height;
	从屏幕坐标到NDC坐标的转换
		float xNDC = (2.0f * xScreen / width) - 1.0f;
		float yNDC = 1.0f - (2.0f * yScreen / height);

	纹理坐标：
		原点：位于屏幕左下角。
		方向：X轴向右增加；Y轴向上增加。
		单位：纹理坐标的范围是 [0, 1]

		NOTE:纹理空间，Direct3D (0，0)为左上角，OpenGL (0，0)为左下角

8 VAO作用：
	主要是当需要来回切换绘制不同物体时候，方便绘制。如果没有VAO，那么在来回绘制物体A和B时，需要每次重复把创建VBO那套代码都执行一次。

9 EBO(IBO)作用
	EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。
	比如通过两个三角形绘制一个矩形时候，两个三角形共有6个顶点，但矩形只需要四个顶点。这里就有重复的顶点。浪费资源。

10 什么是着色器：
	着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；
	它们之间唯一的沟通只有通过输入和输出。

11 顶点属性的位置值：
	layout (location = 0)	//强制指定
	glGetAttribLocation		//动态随机
	这两种方式都可以

12 如何从顶点着色器向片段着色器发送数据
	顶点着色器中定义输出变量，片段着色器中定义输入变量，并且这两个变量名字一样。这样就连接起来了。

	#version 330 core
	layout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0

	out vec4 vertexColor; // 为片段着色器指定一个颜色输出

	void main()
	{
		gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数
		vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色
	}
	///////////////////////
	#version 330 core
	out vec4 FragColor;

	in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）

	void main()
	{
		FragColor = vertexColor;
	}

13 应用程序在 CPU 上传递数据到 GPU 上的着色器的方式
	顶点数据
	uniform

14 unifrom注意事项：
	glGetUniformLocation 查询uniform地址不要求你之前使用过着色器程序
	glUniform4f 但是更新一个uniform之前你必须先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。
		f	函数需要一个float作为它的值
		i	函数需要一个int作为它的值
		ui	函数需要一个unsigned int作为它的值
		3f	函数需要3个float作为它的值
		fv	函数需要一个float向量/数组作为它的值

15 glVertexAttribPointer函数：
	第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。
	第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。
	第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。
	下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。
	第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。
	最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。

16 左手坐标系和右手坐标系对于编码区别：
	对于2D纹理而言，由于Direct3D (左手坐标系) 和 OpenGL(右手坐标系) 在X轴和Y轴上的方向是相同的，
	因此对于2D纹理坐标而言，它们在两种坐标系统中的处理基本相同。

17 经过顶点着色器处理后的顶点位置坐标通常会转换到归一化设备坐标（Normalized Device Coordinates, NDC）空间。
	NDC空间是一种标准化的坐标系统，在OpenGL中，NDC空间的坐标范围通常是-1到1。
	NDC:
		位置范围：-1，1
		颜色范围：0，1

18 赋值给gl_Position范围在-1，1之间的坐标就是裁剪空间坐标
	OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。
	OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到屏幕坐标，
	每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。
	这个过程称为视口变换。

19 什么是纹理的采样：
	使用纹理坐标获取纹理颜色叫做采样(Sampling)

20 关于纹理的一些概念：
	纹理数据: 
		实际的纹理数据（像素颜色值）是存储在一个纹理对象中的，该对象由 OpenGL 创建，并通过调用 glTexImage2D 或类似函数填充。
	纹理单元: 
		在OpenGL中，纹理单元是一组绑定的纹理，每个单元都有一个编号（例如 GL_TEXTURE0、GL_TEXTURE1 等）。
		您可以绑定多个纹理到不同的纹理单元，然后在着色器中使用这些纹理。
	纹理采样器: 
		sampler2D 是一个在着色器中使用的类型，它表示一个 2D 纹理采样器。
		它不直接存储纹理数据，而是告诉着色器应该从哪个纹理单元采样数据。

21 向量
	定义：向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)
	向量相加：就是每个向量的分量分别相加
	向量相减：就是一个向量加上另一个向量的反向量。
	向量相乘：
		点乘：
			两个向量的点乘等于向量的长度数乘结果乘以两个向量之间夹角的余弦值。：
			v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ
			如何计算点乘呢？点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。

			它们之间的夹角记作θ。为什么这很有用？想象如果v¯和k¯都是单位向量，它们的长度会等于1。
			这样公式会有效简化成：v¯⋅k¯=1⋅1⋅cosθ=cosθ
			现在点积只定义了两个向量的夹角。你也许记得90度的余弦值是0，0度的余弦值是1。
			使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）
		叉乘：
			叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。
			如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量

			叉乘的计算：
				a     =	(Ax, Ay, Az)
				b     =	(Bx, By, Bz)
				a x b = (Ay*Bz - Az*By, Az*Bx - Ax*Bz, Ax*By - Ay*Bx)

22 单位向量
	任意向量的每个分量除以向量的长度得到它的单位向量n^

23 矩阵
	矩阵索引：矩阵可以通过(i, j)进行索引，i是行，j是列

	矩阵加减法：
		矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。
		这也就是说加法和减法只对同维度的矩阵才是有定义的。
		一个3×2矩阵和一个2×3矩阵（或一个3×3矩阵与4×4矩阵）是不能进行加减的
	矩阵乘法：
		矩阵与标量相乘：
			和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的每一个元素分别乘以该标量
		矩阵与矩阵相乘：
			限制：
				只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。
				矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅A。

			结果矩阵的维度是(n, m)，n等于左侧矩阵的行数，m等于右侧矩阵的列数。

			矩阵与向量相乘（特殊的矩阵与矩阵相乘，向量可以看成是一个一列多行的矩阵）：
				
	单位矩阵：
		在OpenGL中，由于某些原因我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。
		我们能想到的最简单的变换矩阵就是单位矩阵(Identity Matrix)。单位矩阵是一个除了对角线以外都是0的N×N矩阵
		1 0 0 0
		0 1 0 0
		0 0 1 0
		0 0 0 1
		
		一个向量和单位矩阵相乘，结果还是这个向量，保持不变。

	缩放矩阵：
		（3D缩放矩阵,需要4x4矩阵）
		s1	0	0	0 |		|x|		|s1	* x
		0	s2	0	0 |	*	|y| =		|s2	* y
		0	0	s3	0 |		|z|		|s3	* z
		0	0	0	1 |		|1|		|	1

		（2D缩放矩阵，需要3x3矩阵）
		s1	0	0 |		|x|		|s1	* x
		0	s2	0 |	*	|y|	=	|s2	* y
		0	0	1 |		|1|		|	1

	位移：
		（3D位移矩阵,需要4x4矩阵）
		1	0	0	Tx |	|x|		|x + Tx
		0	1	0	Ty | *	|y|	=	|y + Ty
		0	0	1	Tz |	|z|		|z + Tz
		0	0	0	1  |	|1|		|  1
		
		2D位移矩阵需要3x3矩阵

		齐次坐标(Homogeneous Coordinates)
		向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。
		我们通常不会注意这个问题，因为w分量通常是1.0。
		使用齐次坐标有几点好处：
			它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。
		如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。
	旋转：

	矩阵组合：
		根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中
		在 OpenGL 中，矩阵变换是从右向左进行的，这意味着最后一个应用的变换最先作用于顶点上。
		   位移矩阵            缩放矩阵
		1	0	0	1 |		|2	0	0	0|		|2	0	0	1
		0	1	0	2 | *		|0	2	0	0|	=	|0	2	0	2
		0	0	1	3 |		|0	0	2	0|		|0	0	2	3
		0	0	0	1 |		|0	0	0	1|		|0	0	0	1

		2	0	0	1		x		2x + 1
		0	2	0	2	*	y	=	2y + 2	
		0	0	2	3		z		2z + 3
		0	0	0	1		1		   1
